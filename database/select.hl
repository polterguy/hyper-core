/*
 * File responsible for selecting items from our database.
 * Expects [database] and [table] as arguments.
 *
 * It also expects the HTTP method to be of type 'GET'.
 *
 * Any optional HTTP GET QUERY parameters, will be used to refine the results 
 * of your select query.
 *
 * Any '[order-by]' and '[order-dir]' QUERY parameters, will order your results accordingly.
 * Any '[limit]' and '[offset]' QUERY parameters, will become a limit and offset
 * parameter to your select SQL.
 *
 * All other HTTP GET QUERY parameters becomes a part of the additional "where" clause,
 * with their names being the column name, and their value expected to be in the form of
 * "type:operand:value", where type can be e.g. "string", operand can be e.g. "like" or
 * ">=" etc, and value can be e.g. "%foo%" or "2018-01-01T13:34" - The latter which is
 * a "date" value.
 *
 * Obviously, this file will throw an exception, if you create erronous SQLs.
 * It does no validation of your SQL, except of course guarding against SQL insertion attacks,
 * but leaves it up to you to ensure you create SQL statements, which are legal according to your
 * database schema.
 */


/*
 * Sanity checking arguments.
 */
micro.lambda.contract.min:x:/..
  database:string
  table:string


/*
 * Sanity checking HTTP method.
 */
p5.web.request.get-method
if:x:/@p5.web.request.get-method?value
  !=:GET
  throw:This REST service requires you to use a GET HTTP method for your request.


/*
 * Opening up our database connection, and evaluating our select SQL statement, echoing the results
 * to the client as JSON.
 */
p5.mysql.connect:[{0}]
  :x:/../*/database?value

  /*
   * Our actual SQL, which is further parametrised, according to arguments given by the client, 
   * as HTTP GET QUERY parameters.
   *
   * First retrieving our columns, making sure we guard against SQL insertion attacks.
   */
  .defaults
    [columns]:*
  p5.web.query.get:[columns]
  .cols:

  /*
   * Splitting each column name, which should be separated by "," 
   * and looping through each column name, and wrapping it inside of
   * a pair of backticks (`), to support "funny column names".
   */
  split:x:(/@p5.web.query.get/*|/@.defaults/*)/$?value
    =:,
  for-each:x:/@split/*?name

    /*
     * Making sure we guard against SQL isertion attacks on column's name.
     */
    replace:x:/@_dp?value
      src:`
      dest:\`
    set:x:/@.cols?value
      src:{0}, `{1}`
        :x:/@.cols?value
        :x:/@replace?value

  /*
   * Trimming excessive "," characters in the beginning of our column declaration.
   */
  trim-left:x:/@.cols?value
    chars:,

  /*
   * Now we know which columns client requests, in addition to our table name.
   *
   * Making sure we don't allow for SQL insertion attacks on the table name first though.
   */
  replace:x:/../*/table?value
    src:`
    dest:\`
  eval-x:x:/+
  .sql:select {0} from `{1}`
    :x:/@trim-left?value
    :x:/@replace?value

  /*
   * Further parametrising our SQL according to GET QUERY parameters supplied by client.
   */
  .no:int:0
  p5.web.query.list
  for-each:x:/@p5.web.query.list/*?name

    /*
     * Since we have 5 "special parameters", we'll need to check for these, before
     * we allow for our "generic parameter logic" to kick in, and do its thing.
     */
    switch:x:/@_dp?value

      /*
       * Ignoring [offset], [limit], [columns], [order-by] and [order-dir],
       * since they're handled especially further down.
       */
      case:[columns]
      case:[offset]
      case:[limit]
      case:[order-by]
      case:[order-dir]
        continue
      default

        /*
         * Appending either "where" or "and" to our SQL, depending upon whether or
         * not this our first [for-each] iteration, implying the first parameter we
         * add to our SQL.
         */
        if:x:/@.no?value
          =:int:0

          /*
           * First generic parameter, making sure we add a "where" clause.
           */
          set:x:/@.sql?value
            src:{0} where
              :x:/@.sql?value

        else

          /*
           * Not the first parameter, hence we add an "and" clause.
           */
          set:x:/@.sql?value
            src:{0} and
              :x:/@.sql?value

        /*
         * Retrieving type, value, and operand of our QUERY parameter, and handling it accordingly.
         */
        p5.web.query.get:x:/@_dp?value

        /*
         * Splitting query value to get "type", "operand", and "value".
         */
        split:x:/@_dp?value
          =:":"

        /*
         * Retrieving our "type" and "operand", and removing them from the above
         * [split] results afterwards.
         */
        eval-x:x:/+
        .type:x:/@split/0?name
        eval-x:x:/+
        .operand:x:/@split/1?name
        set:x:/@split(/0|/1)

        /*
         * In case "value" parts contains a ":", there will more than one
         * remaining item in above [split] result now, at which point we'll
         * need to join them with ":" being our [sep] character.
         */
        join:x:/@split/*?name
          sep:":"

        /*
         * Sanity checking "type", by making sure it's a type that
         * we know how to handle, to prevent from e.g. SQL insertion attacks, etc.
         *
         * TODO: Check up that we add all types that MySQL supports.
         */
        switch:x:/@.type?value
          case:bool
          case:int
          case:long
          case:date
          case:string
          case:decimal
            // Need to have some node in this lambda, to prevent fall through to our default.
            .foo
          default
            throw:Type '{0}' is not supported
              :x:/@.type?value

        /*
         * Sanity checking "operand", by making sure it's an operand that
         * we know how to handle, to prevent from e.g. SQL insertion attacks, etc.
         *
         * TODO: Check up that we add all operands that MySQL supports.
         */
        switch:x:/@.type?value
          case:=
          case:!=
          case:like
          case:>
          case:<
          case:>=
          case:<=
            // Need to have some node in this lambda, to prevent fall through to our default.
            .foo
          default
            throw:Operand {0} is not supported
              :x:/@.operand?value

        /*
         * Making sure we prevent from SQL insertion attack in "column name" parts.
         */
        replace:x:/@_dp?value
          src:`
          dest:\`

        /*
         * Dynamically building SQL accordingly.
         *
         * The first parts are our existing SQL, the second the column name, the third
         * our operand (>, !=, <=, like, etc), and the fourth part the value to compare against.
         */
        set:x:/@.sql?value
          src:{0} `{1}` {2} @NO{2}
            :x:/@.sql?value
            :x:/@replace?value
            :x:/@.operand?value
            :x:/@.no?value

        /*
         * Adding SQL parameter to [p5.mysql.select] invocation.
         */
        set:x:/+/*/*?name
          src:@NO{0}
            :x:/@.no?value
        add:x:/..p5.mysql.connect/*/p5.mysql.select
          src
            foo:x:/@p5.web.query.get/*?value

        /*
         * Increamenting "counter", which dynamically creates our SQL parameter's names.
         */
        set:x:/@.no?value
          +:x:/@.no?value
            _:1

  /*
   * Further parametrising our SQL according to [offset] and [limit] GET QUERY parameters supplied by client.
   *
   * Notice, we default offset to 0 and limit to 10, to avoid exhausting server resources by making humongously
   * large selects.
   *
   * We also throw an exception if client tries to select more than 1000 records, to avoid having the server
   * being exhausted by erronous client-side code.
   */
  .defaults
    [order-dir]:asc
    [limit]:long:10
    [offset]:long:0
  p5.web.query.get:[order-by]
  p5.web.query.get:[order-dir]
  p5.web.query.get:[limit]
  p5.web.query.get:[offset]

  /*
   * Making sure client doesn't try to select more than 1000 records.
   */
  if:x:(/..p5.mysql.connect/*/p5.web.query.get/[3,4]/*|/@.defaults/1)/$?value.long
    >:long:1000
    throw:You can't select more than 1000 records at the time.

  /*
   * Checking if client supplied an "order by" QUERY parameter.
   */
  if:x:/..p5.mysql.connect/*/p5.web.query.get/[1,2]/*?value

    /*
     * Sanity checking direction for "order by" parts.
     */
    if:x:(/..p5.mysql.connect/*/p5.web.query.get/[2,3]/*|/@.defaults/0)/$?value
      !=:asc
      and:x:(/..p5.mysql.connect/*/p5.web.query.get/[2,3]/*|/@.defaults/0)/$?value
        !=:desc
      throw:Only provide 'asc' or 'desc' as '[order-dir]' query parameter.

    /*
     * Making sure we guard against SQL insertion attacks in our "order by" parameter.
     */
    replace:x:/..p5.mysql.connect/*/p5.web.query.get/[1,2]/*?value
      src:`
      dest:\`
    set:x:/@.sql?value
      src:{0} order by `{1}` {2}
        :x:/@.sql?value
        :x:/@replace?value
        :x:(/..p5.mysql.connect/*/p5.web.query.get/[2,3]/*|/@.defaults/0)/$?value

  /*
   * Adding tail (limit and offset).
   */
  set:x:/@.sql?value
    src:{0} limit @limit offset @offset
      :x:/@.sql?value

  /*
   * Executing actual SQL, now that we have parametrised it, and returning results to client as JSON.
   */
  p5.mysql.select:x:/@.sql?value
    @limit:x:(/..p5.mysql.connect/*/p5.web.query.get/[3,4]/*|/@.defaults/1)/$?value.long
    @offset:x:(/..p5.mysql.connect/*/p5.web.query.get/[4,5]/*|/@.defaults/2)/$?value.long

  /*
   * Making sure we accurately set the "Content-Type" of our HTTP response, before we echo our
   * JSON results back to caller.
   */
  p5.web.header.set:Content-Type
    src:application/json

  /*
   * Checking for empty result, at which point we simply return empty JSON, and return early.
   */
  if:x:/@p5.mysql.select/*
    not
    p5.web.echo:[]
    return
    

  /*
   * Transforming above results to JSON and returning it to client as such.
   *
   * Notice, to make sure we echo this as a JSON array to the client, we explicitly 
   * set all names of all children of our [p5.mysql.select] invocation to "empty".
   */
  set:x:/@p5.mysql.select/*?name
    src:
  lambda2json:x:/@p5.mysql.select/*

  /*
   * Returning JSON to caller.
   */
  p5.web.echo:x:/@lambda2json?value
